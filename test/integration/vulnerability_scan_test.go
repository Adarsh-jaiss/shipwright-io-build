// Copyright The Shipwright Contributors
//
// SPDX-License-Identifier: Apache-2.0

package integration_test

import (
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"

	buildapi "github.com/shipwright-io/build/pkg/apis/build/v1beta1"
	test "github.com/shipwright-io/build/test/v1beta1_samples"
)

var _ = Describe("Vulnerability scan tests", func() {

	var (
		cbsObject      *buildapi.ClusterBuildStrategy
		buildObject    *buildapi.Build
		buildRunObject *buildapi.BuildRun
		buildSample    []byte
		buildRunSample []byte
	)

	// Load the ClusterBuildStrategies before each test case
	BeforeEach(func() {
		cbsObject, err = tb.Catalog.LoadCBSWithName(STRATEGY+tb.Namespace, []byte(test.ClusterBuildStrategyForVulnerabilityScanning))
		Expect(err).To(BeNil())

		err = tb.CreateClusterBuildStrategy(cbsObject)
		Expect(err).To(BeNil())

	})

	// Delete the ClusterBuildStrategies after each test case
	AfterEach(func() {
		if buildObject != nil {
			_, err = tb.GetBuild(buildObject.Name)
			if err == nil {
				Expect(tb.DeleteBuild(buildObject.Name)).To(BeNil())
			}
		}

		err := tb.DeleteClusterBuildStrategy(cbsObject.Name)
		Expect(err).To(BeNil())
	})

	// Override the Builds and BuildRuns CRDs instances to use
	// before an It() statement is executed
	JustBeforeEach(func() {
		if buildSample != nil {
			buildObject, err = tb.Catalog.LoadBuildWithNameAndStrategy(BUILD+tb.Namespace, STRATEGY+tb.Namespace, buildSample)
			Expect(err).To(BeNil())
		}

		if buildRunSample != nil {
			buildRunObject, err = tb.Catalog.LoadBRWithNameAndRef(BUILDRUN+tb.Namespace, BUILD+tb.Namespace, buildRunSample)
			Expect(err).To(BeNil())
		}
	})

	Context("when a build with vulnerability scan options is defined", func() {

		BeforeEach(func() {
			buildSample = []byte(test.BuildWithVulnerabilityScanOptions)
			buildRunSample = []byte(test.MinimalBuildRun)
		})

		It("should fail the builRun with a Reason", func() {

			Expect(tb.CreateBuild(buildObject)).To(BeNil())

			buildObject, err = tb.GetBuildTillValidation(buildObject.Name)
			Expect(err).To(BeNil())

			Expect(tb.CreateBR(buildRunObject)).To(BeNil())

			br, err := tb.GetBRTillCompletion(buildRunObject.Name)
			Expect(err).To(BeNil())

			Expect(br.Status.GetCondition(buildapi.Succeeded).Status).To(Equal(corev1.ConditionFalse))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Reason).To(Equal("VulnerabilitiesFound"))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Message).To(ContainSubstring("Vulnerabilities have been found in the image"))
		})
	})

	Context("When a buildrun with vulnerability scan is defined", func() {
		BeforeEach(func() {
			buildSample = []byte(test.MinimalBuild)
			buildRunSample = []byte(test.MinimalBuildRunWithVulnerabilityScan)
		})

		It("should fail the builRun with a Reason", func() {

			Expect(tb.CreateBuild(buildObject)).To(BeNil())

			buildObject, err = tb.GetBuildTillValidation(buildObject.Name)
			Expect(err).To(BeNil())

			Expect(tb.CreateBR(buildRunObject)).To(BeNil())

			br, err := tb.GetBRTillCompletion(buildRunObject.Name)
			Expect(err).To(BeNil())

			Expect(br.Status.GetCondition(buildapi.Succeeded).Status).To(Equal(corev1.ConditionFalse))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Reason).To(Equal("VulnerabilitiesFound"))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Message).To(ContainSubstring("Vulnerabilities have been found in the image"))
		})
	})

	Context("When both build and buildrun with vulnerability scan is defined", func() {
		BeforeEach(func() {
			buildSample = []byte(test.BuildWithDisableVulnerabilityScan)
			buildRunSample = []byte(test.MinimalBuildRunWithVulnerabilityScan)
		})

		It("should override the vulnerability settings from builRun", func() {

			Expect(tb.CreateBuild(buildObject)).To(BeNil())

			buildObject, err = tb.GetBuildTillValidation(buildObject.Name)
			Expect(err).To(BeNil())

			Expect(tb.CreateBR(buildRunObject)).To(BeNil())

			br, err := tb.GetBRTillCompletion(buildRunObject.Name)
			Expect(err).To(BeNil())

			Expect(br.Status.GetCondition(buildapi.Succeeded).Status).To(Equal(corev1.ConditionFalse))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Reason).To(Equal("VulnerabilitiesFound"))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Message).To(ContainSubstring("Vulnerabilities have been found in the image"))
		})
	})

	Context("When a standalone buildrun with vulnerability scan is defined", func() {
		var standAloneBuildRunSample []byte
		var standaloneBuildRunObject *buildapi.BuildRun

		BeforeEach(func() {
			standAloneBuildRunSample = []byte(test.OneOffBuildRunWithVulnerabilityScan)
			standaloneBuildRunObject, err = tb.Catalog.LoadStandAloneBuildRunWithNameAndStrategy(BUILDRUN+tb.Namespace+"-standalone", cbsObject, standAloneBuildRunSample)
			Expect(err).To(BeNil())
		})

		It("should fail the builRun with a Reason", func() {

			Expect(tb.CreateBR(standaloneBuildRunObject)).To(BeNil())

			br, err := tb.GetBRTillCompletion(standaloneBuildRunObject.Name)
			Expect(err).To(BeNil())

			Expect(br.Status.GetCondition(buildapi.Succeeded).Status).To(Equal(corev1.ConditionFalse))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Reason).To(Equal("VulnerabilitiesFound"))
			Expect(br.Status.GetCondition(buildapi.Succeeded).Message).To(ContainSubstring("Vulnerabilities have been found in the image"))
		})
	})

})
